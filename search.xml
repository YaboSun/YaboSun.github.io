<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE--自增自减运算]]></title>
    <url>%2F2018%2F04%2F07%2FJavaSE--%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[Java中，对于初学者来说，很容易混淆的一个知识点就是对于运算符这部分关于自增自减的理解，自增(++)和自减(–)两种运算符，这两种运算符帮助我们在编写程序的时候简化了代码。这里需要注意的几点如下： 1234567891011121314public class NumAdd &#123; public static void main(String []args)&#123; /** * 1、这里不管执行++还是--都是需要确定的值 * 2、b = a++（--）执行顺序是先赋值再自增（自减） * 3、b = ++（--）a执行顺序是先自增（自减）再赋值 */ int a = 3; int b = a++; System.out.println(b); int c = ++b; System.out.print(c); &#125;&#125; 通过代码可以看出自增和自减运算符号放在变量的前面，如 ++a, 表示先执行运算，再生成值， 放在变量的后面，如: a++,先生成值，再执行运算]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>运算符</tag>
        <tag>自增自减</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE--简单Java类开发要求]]></title>
    <url>%2F2018%2F04%2F07%2FJavaSE--%E7%AE%80%E5%8D%95Java%E7%B1%BB%E5%BC%80%E5%8F%91%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[简单Java类的开发应该是所有Java开发过程中最简单也是最基础的一种开发，说白了就是不会涉及到一些循环、判断等结构的Java类开发，比如说简单的一个图书管理系统等等，通常是Java基础学习完成后第一个小的项目。对于简单开发类，开发要求如下：1、类名称必须存在有意义，比如说：Book、Empire等2、类中的所有属性必须使用private封装，封装后的属性必须提供setter和getter方法3、类之中可以提供任意多个构造方法，但是必须保留有一个无参构造方法4、类之中不允许出现任何的输出语句，所有的输出必须交给被调用处5、类之中需要提供一个取得对象完整信息的方法，暂定为getInfo，而且返回string类型 简单案例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 定义一个有意义的类：雇佣员工类 */class Empire&#123; private int mnEmpNum; private String mstrEmpName; private String mstrJob; private double mdSalary; private double mdComm; /** * 无参构造函数 */ public Empire()&#123;&#125; /** * 有参构造函数 */ public Empire(int nNum, String strName, String strEmpJob, double dSal, double dCom)&#123; mnEmpNum = nNum; mstrEmpName = strName; mstrJob = strEmpJob; mdSalary = dSal; mdComm = dCom; &#125; /** * setter方法 * @param nEmpNum */ public void setMnEmpNum(int nEmpNum)&#123; mnEmpNum = nEmpNum; &#125; public void setMstrEmpName(String strEmpName)&#123; mstrEmpName = strEmpName; &#125; public void setMstrJob(String strJob)&#123; mstrJob = strJob; &#125; public void setMdSalary(double dSalary)&#123; mdSalary = dSalary; &#125; public void setMdComm(double dComm)&#123; mdComm = dComm; &#125; /** * getter方法 * @return */ public int getMnEmpNum() &#123; return mnEmpNum; &#125; public String getMstrEmpName() &#123; return mstrEmpName; &#125; public String getMstrJob() &#123; return mstrJob; &#125; public double getMdSalary() &#123; return mdSalary; &#125; public double getMdComm() &#123; return mdComm; &#125; public String getInfo()&#123; return "雇员编号" + mnEmpNum + "\n" + "雇员姓名" + mstrEmpName + "\n" + "雇员职位" + mstrJob + "\n" + "雇员薪水" + mdSalary + "\n" + "佣 金" + mdComm + "\n"; &#125;&#125; 在构造了一个简单的类以后，接下来要做的事就是编写测试函数（主函数） 123456public class TestDemo &#123; public static void main(String []args)&#123; Empire empire = new Empire(001,"Frank","CEO",10245.2,3010.7); System.out.println(empire.getInfo()); &#125;&#125; 程序输出结果： 12345678雇员编号1雇员姓名Frank雇员职位CEO雇员薪水10245.2佣 金3010.7Process finished with exit code 0 对于程序中的setter以及getter方法，有时候程序中并不会用到，但是需要设置，这里也能体现类的很好的封装性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>简单Java类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE--一维数组创建的几种方法]]></title>
    <url>%2F2018%2F04%2F07%2FJavaSE--%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组可以说是对于每种语言学习中的最基础的数据结构之一，几乎是在所有项目中都会涉及到数组的使用，接下来就详细介绍一下数组的声明、创建和初始化以及实例代码解析 声明123数据类型 数组名称[]或数据类型[] 数组名称 //首选的方法 这部分来说俩种声明方式的效果是相同的，但是推荐首选第一种方法来声明，因为第一种方法更加直观，更具有可读性，可以通过声明看出是一种引用类型，而不是普通的数据类型具体整型数组声明如下： 123声明ｉｎｔ型数组ｉｎｔ[] arrNum;int arrNum[]; 这里的命名看个人喜好，不管怎样要有自己的规范，我个人一般是加前缀arr另外需要注意的是，Java语言中声明数组时不能指定其长度，因为数组是一种引用型变量，也就是说在数组定义时实质上是定义了一个引用变量（或者说是一个指针），而此时这个引用变量还没有指向任何有效的内存，并且这时候在内存中还没有开辟任何内存空间，所以不能指定长度.错误定义 12//int[5] arrNum;//int arrNum[5]; 那么这个时候学过C++的可能会问，为什么在C++中这样定义数组是合法的呢？而且是这样定义以后就可以使用，Java却需要创建、初始化以后才可以使用？因为C和C++中的数组就是内存块，而Java中出于安全性考虑，定义的数组是对象，数组保存的仅仅是对象的引用，而不是对象本身，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。 创建Java使用new关键字创建数组，如果数组创建没有初始化，必须指定数组的大小 123arrNum = new int[5]；//正确arrNum = new int[]&#123;0,1,2,3,4&#125;；//正确//arrNum = new int[];//错误，未初始化也未指定数组的大小 案例一： 123456789101112public class ArrayDemo &#123; public static void main(String []args)&#123; int [] arrNum; int [] arrNum1; int [] arrNum2 = new int[5]; arrNum = new int[5]; arrNum1 = new int[]&#123;1,2,3,4,5&#125;; System.out.println(arrNum[0]); System.out.println(arrNum1[0]); System.out.println(arrNum2[0]); &#125;&#125; 可以看到以上这三种方法创建数组都是正确的 初始化其实在上面的案例中已经涉及到了数组的初始化，数组的初始化分为静态初始化、动态初始化以及默认初始化动态初始化就是在创建过程中只是声明数组的大小，而由系统为数组分配值 123int [] arrNum;arrNum = new int[5];int [] arrNum = new int[5];//简化方式 静态初始化 就是由程序员显式的指定每个数组元素的值 123int [] arrNum1;arrNum1 = new int[]&#123;1,2,3,4,5&#125;;int[] arrNum1 = &#123;1,2,3,4,5&#125;;//简化方式 这里对于静态初始化的方式，推荐使用第一种方式，不推荐简化方式。 堆栈分析以上数组创建的方式，其实归根到底总共是俩种方式：方式一：12int[] arrNum;arrNum = new int[5]; 对于这种方式，实质上第一句是创建了一个引用对象，可以认为是在栈内存中开辟了一个对象，而为这个对象创建了一个空指针，这时候如果没有第二句，那么编译器就会报错空指向异常，第二句的作用就是在堆内存中开辟出大小为５的内存空间方式二： 1int[] arrNum = new int[5]; 实际上这种方法就是省去了第一步，也可以说是将对象在堆栈中开辟的过程合为了一个过程 引用传递既然前面提到了数组实际上是一种引用类型，那么数组是一定可以发生引用传递的，什么叫引用传递？实质就是同一块堆内存空间能够被不同的栈空间所访问，那么数组的引用传递是怎么实现？案例二： 12345678910111213141516171819public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arrNum; arrNum = new int[]&#123;1, 2, 3, 4, 5&#125;; int[] temp = arrNum; temp[0] = 10; for (int i = 0;i &lt; arrNum.length; i++)&#123; System.out.println(arrNum[i]); &#125; &#125;&#125;输出：102345Process finished with exit code 0 这个时候对于语句int[] temp = arrNum; 执行的就是将temp数组在栈内存空间中开开辟的地址指向和data数组同样的堆内存地址，而这个时候改变temp[0]的值实质上同时改变了arrNum[0]的值。 总结以上就是详细的学习了数组的一些相关操作，但是这只是为了掌握数据的底层一些设计，在实际工作中，不管动态还是静态的方法一般都不会用到，因为数组有一个最大的缺点就是数组的长度不能改变，实际过程中一般都是通过传值或者别的方式进行动态的生成数组，而不是提前指定数组的大小。 Java创建数组的几种方式数组在C++和java中的区别]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>数组定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GeoSpark学习--初识GeoSpark]]></title>
    <url>%2F2018%2F04%2F02%2FGeoSpark%E5%AD%A6%E4%B9%A0--%E5%88%9D%E8%AF%86GeoSpark%2F</url>
    <content type="text"><![CDATA[背景 传统的不足：数据存储方面：1、现有的数据存储主要是多依赖关系型数据库，比如Oracle等，但是关系型数据库在海量数据管理、高并发读写以及扩展性方面有很大的局限2、传统的空间数据存储方式不但难以扩展，而且随着数据的激增读写性能存在极大瓶颈3、传统的分布式文件系统虽然可以存放在不同的节点上，但这种分布式文件系统所支持的扩展性有限数据分析方面：大数据时代的数据是处处连接的，每个连接都是一个传感器，这些传感器无时无刻都在进行数据的采集，所以说数据的变化很快，在这样的背景下，迫切需要GIS能够做到低延迟的分析处理工作 技术发展 1、存储去结构化非关系型数据库比如说HBase、Redis、MongoDB、InfoGrid，这些数据库不需要预先定义模式，并且可以在系统运行的时候动态增加或删除节点，避免了停机维护，提高了拓展性和可靠性另外这些非关系型数据库没有共享架构，数据一般是存储在本地服务器上，可以直接读取数据，提高了数据的读取性能。2、计算内存化对于Hadoop来说主要进行离线数据的计算，应对低延迟的应用场景比较困难，另外Hadoop使用MapReduce模型，该模型将复杂模型使用简单的映射规约，对于复杂的算法逻辑支持不充分，并且数据存储在硬盘上，很容易收IO瓶颈的影响，所以对于处理GIS数据乏力。而新的技术Spark启用了内存分布式数据集，支持更多的范式，而且配有一个数据处理模型，所以在处理GIS数据中性能更好。3、分析去模型化传统的GIS空间数据分析需要先建立分析模型，比如说考虑影响因子，权重，最后综合各影响因素进行建模，然而大数据环境下的数据是时刻在变化的，这样就无法满足，所以去模型化是最终的发展方向 GeoSpark 这里主要介绍GeoSpark以及我调试运行过程中遇到的问题GeoSpark是在Apache Spark第三方项目中的一个子项目，也是一个用于处理大规模空间数据的集群计算系统，目前最新版本更新到v1.1.0（2018年3月13日）。GeoSpark继承自Apache Spark，并拥有一系列具有创造性的空间弹性分布式数据集（SRDDs），借助机器这些数据集可以有效的加载，处理并分析大规模的空间数据。GeoSpark为Apache开发人员提供了API使得他们能够利用SRDDs方便的开发空间分析程序，这些程序为地理空间查询提供了有力的支持。 主要功能GeoSparkSQL最新版本的GeoSpark主要是包含了新的SQL功能，新增了四叉树和R树的索引解析并修复了一些bug。这个版本最主要的就是包含了一个完整的GeoSparkSQL版本，GeoSparkSQL完全支持Apache Spark SQL。SRDDs支持特殊的SRDDs，包括PointRDD,RectangleRDD,PolygonRDD以及LineStringRDD。空间分割支持的空间分割技术有四叉树、KDB树、R树、沃罗诺伊图（Voronoi diagram）、均匀网络（Uniform grids）空间索引支持四叉树、R树、以及空间K近邻查询 调试之路好，开搞，以下内容较多，纯属个人踩坑记录，想直接运行的跳到文章末尾即可1、搭建环境 系统 IDE Spark Scala Jdk Maven Sbt Ubuntu16.04 IntelliJ IDEA2017.3 2.2.1 2.11.12 1.8.0_151 3.5.3 1.1.1 基本的环境都搭建好了，没遇到什么问题，具体安装教程网上都有，就不多说，不过在我安装过程中也遇到了坑，这里就不一一说明，有遇到问题的可以问我2、Git Clone项目地址 这是什么鬼？怎么迁项目还出了问题，应该是权限的问题 稍微等一会儿就Clone好了，这时候在home可以看到 项目的位置的话看个人习惯，开始迁下来以后权限是只读的，这使得后面使用IDEA导入时候会出现权限的问题，所以需要修改权限修改权限命令sudo chmod -R 777 &lt;yourfilename&gt;这里简单说一下这个命令 chmod 修改文件和文件夹读写执行属性，777 指的就是二进制编码，总共有3位111就是可读可写可编译，即拥有全权限，可写 w=4可读 r=2可执行 x=1 ，详细介绍chown和chmod区别get !3、Package + Compile这里说一下，我最开始没有跑GeoSpark，而是调的其中的一个案例，如果只是想简单的在本地IDE运行该项目的话，完全不需要这个步骤，然而……我还是照着做了这部分基本没什么问题，只要你maven还有Sbt装好了，按照项目说明一步步执行，就都可以编译通过4、导入项目import project-&gt;GeoSparkTemplateProject/geospark/java-&gt;import project from external model-&gt;maven这里需要注意运行Java部分的代码时，导入项目为maven项目，然后一路next即可，选择SDK时候添加你的jdk1.8 5、build+run/src/main/Example 点击运行，好，报错 123456789101112131415161718192021222324252627282930Exception in thread "main" java.lang.IllegalAccessError: tried to access method com.google.common.base.Stopwatch.()V from class org.apache.hadoop.mapred.FileInputFormatat org.apache.hadoop.mapred.FileInputFormat.getSplits(FileInputFormat.java:312)at org.apache.spark.rdd.HadoopRDD.getPartitions(HadoopRDD.scala:199)at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:252)at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:250)at scala.Option.getOrElse(Option.scala:121)at org.apache.spark.rdd.RDD.partitions(RDD.scala:250)at org.apache.spark.rdd.MapPartitionsRDD.getPartitions(MapPartitionsRDD.scala:35)at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:252)at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:250)at scala.Option.getOrElse(Option.scala:121)at org.apache.spark.rdd.RDD.partitions(RDD.scala:250)at org.apache.spark.rdd.MapPartitionsRDD.getPartitions(MapPartitionsRDD.scala:35)at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:252)at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:250)at scala.Option.getOrElse(Option.scala:121)at org.apache.spark.rdd.RDD.partitions(RDD.scala:250)at org.apache.spark.SparkContext.runJob(SparkContext.scala:2126)at org.apache.spark.rdd.RDD$$anonfun$aggregate$1.apply(RDD.scala:1115)at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)at org.apache.spark.rdd.RDD.withScope(RDD.scala:362)at org.apache.spark.rdd.RDD.aggregate(RDD.scala:1108)at org.apache.spark.api.java.JavaRDDLike$class.aggregate(JavaRDDLike.scala:426)at org.apache.spark.api.java.AbstractJavaRDDLike.aggregate(JavaRDDLike.scala:45)at org.datasyslab.geospark.spatialRDD.SpatialRDD.analyze(SpatialRDD.java:430)at org.datasyslab.geospark.spatialRDD.SpatialRDD.analyze(SpatialRDD.java:404)at org.datasyslab.geospark.spatialRDD.PointRDD.(PointRDD.java:300)at example.Example.testSpatialRangeQuery(Example.java:156)at example.Example.main(Example.java:128) 仔细看，主要是IllegalAccessError，Google搜索1、https://blog.csdn.net/superzyl/article/details/53764731开始解决，一句话就是项目中的依赖出现了问题，guava冲突，但是在我的pom.xml文件中并没有这个依赖啊？ 无果。。2、http://www.bubuko.com/infodetail-1909839.html还是那个原因，但是给出了一点具体的解决办法查看jar包，发现有多个版本的guava，这部分后面项目开发者都进行了修改，现在看到的只有一个版本 我当时是有4个，然后我具体不知道是哪个版本需要，就保留了16.0.1，把其余的都删了，再重新进行整合，编译，结果还是同样的错误到这里为止，我就不清楚该怎么解决，期间删了项目重新下载，删除其他版本的guava还是没用3、问导师这个时候我知道问题肯定出在依赖上，应该是版本依赖冲突或者缺少依赖的问题，但是不知道具体在哪里导师给我添加了GeoSpark还有Babylon的依赖，这里添加的话就是去maven的官网，对应依赖的地方搜索你想要添加的，就会得到对应的代码，然后复制粘贴到项目的pom.xml文件中即可，这部分我是刚接触还不太明白，后面慢慢熟悉。然而添加以后还是不行，我又开始自己琢磨4、看原项目说明文档这时候重新仔细的又看了一下原项目的说明，按照说的都做了不知道问题出在哪里5、问大佬实在不知道该怎么办，看了issue中也没有这个错误的回答，问了下师兄说需要打包编译吧，我这里比较不确定，索性我直接开了个issue，当时其实抱着问问的心态，压根儿没想着大佬会回复我，因为国内好多博客下面提问，从来没有收到回复=-= 不要嘲笑我蹩脚的英文。。。没过几分钟就收到了回复，他说根本还是Spark依赖冲突的问题，让我理解dependency scope Scope几种模式：1、test范围指的是测试范围有效，在编译和打包时都不会使用这个依赖2、compile范围指的是编译范围有效，在编译和打包时都会将依赖存储进去3、provided依赖：在编译和测试的过程有效，最后生成war包时不会加入，诸如：servlet-api，因为servlet-api，tomcat等web服务器已经存在了，如果再打包会冲突4、runtime在运行的时候依赖，在编译的时候不依赖一般情况下默认是compile我按照他说的又重新安装了IDEA，把我原来的配置文件删除，再重新导入项目，直接运行，还是报错。。。没办法了，只能再继续提问 收到回复赶紧试了一下 ！！！ 总结 最新版的项目只要配置好环境，迁下来运行就可以了说说这个过程，花了很久的时间，虽然最后还是没能自己解决，但是过程确实学到了很多的东西，这只是本地IDE中运行项目，后面需要在Spark cluster运行，到现在很多东西还是很模糊，慢慢一点点学习积累吧！]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>GeoSpark</tag>
        <tag>maven</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习系列——ImageView用法]]></title>
    <url>%2F2018%2F01%2F30%2FAndroid%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ImageView%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用Android开发也有一段时间，因为是从一开始就做项目，很多东西就是模仿着做，也没有仔细研究，准备把一些开发过程中遇到的需要注意区分的细节写下来，让思路清晰一些，以后用到也可以看看。 ImageView用法 ImageView就是Android中用来显示图片的一个控件 区分属性android:src和android:background设置俩个ImageView，分别用不同属性显示效果如下：可以看出src属性是将图片加载，不会随区域的变化而改变，background是使用图片填充 ImageView 和ImageButton都可以设置点击，用法其实没什么区别，唯一区别就是ImageButton 拥有默认背景，而ImageView 没有，如下所示显示效果可以看到ImageButton是有背景色的另外，通过ImageButton 的类定义我们可以看到ImageButton 继承自ImageView而 ImageView 类又是继承自View 类]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GithubPages+Hexo搭建个人博客]]></title>
    <url>%2F2018%2F01%2F28%2FGithubPages%2BHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[如果是有个人服务器的话，建议选择WP（wordpress）搭建个人博客，可以参考这篇文章VPS+LNMP+WordPress搭建个人网站。没有的话，Hexo确实是一个很好的选择，一来简洁大方，十分优雅，二来能够自己折腾，可以设计的地方很多。好，话不多说，接下来详细介绍我搭建个人博客的过程。我的GithubPages+Hexo博客欢迎访问我的Hexo博客 安装环境win10企业版 64位Node.js v8.9.3Git version2.15.0 相关步骤 安装Node.js 步骤1、到Node.js官方网址下载对应版本一般我们下载最新的LTS（长期支持）版本即可，本教程以Version8.9.3对应的msi64bit安装为例，其他版本类似步骤2、双击下载的安装包将出现如下界面：步骤3、一路点击next即可，注意选择安装路径，这个看个人喜好，我一般软件安装在D盘，我这里选择的安装路径是D:\nodejs步骤4、检查是否安装成功win+R快捷键输入cmd1输入 node -v 输入时注意中间的空格即可显示安装的Node.js版本 安装Git 步骤1、到官方网址下载对应的版本Git各平台下载地址：https://git-scm.com/downloadWindows平台Git下载地址：https://git-scm.com/download/win安装过程不需要多说什么，一路下一步即可。安装成功后在桌面或文件夹中点击鼠标右键可以看到Git Bash Here选项。步骤2、检查Git版本 1输入 git --version 输入注意是双- GitHubPages配置 步骤1、进入GitHub官网注册账号，具体注册这里不再赘述。官网连接 https://github.com/步骤2、新建项目注意这里的Repository名字格式一定是账户名.github,io比如我的就是：yabosun.github.io在建好的项目右侧有Settings向下拉可看到GitHub Pages点击对应的网址你会发现该项目已经被部署到网络上，你可以通过外网来访问它。 安装Hexo 在自己认为合适的地方创建一个文件夹，用来存放之后博客的文档以及配置文件，我是在F盘新建了文件夹，并命名为BlogWorkspace。然后点击进入创建的文件夹，点击鼠标右键选择Git Bash Here 1输入 npm install hexo -g 开始安装Hexo 这个过程需要几分钟时间不等，看个人网络状况。安装完成后，检查是否安装成功 1输入 hexo -v 初始化该文件夹1输入 hexo init 这个过程也有点漫长需要等待几分钟，最后出现Start blogging with Hexo！表示安装成功。 开始安装所需要的组件1输入 npm install 首次体验Hexo1输入 hexo g 可以开启本地服务器1输入 hexo s 点击http://localhost:4000/ 可以正式体验hexo，出现Hexo的界面就表示安装成功了 Hexo连接GithubPages 将Hexo与GithubPages联系起来，首次运行的话这里需要设置Git的user name和emailctrl+C结束之前的sever 1输入 git config --global user.name "yabosun" 这里的username为你自己的GitHub用户名 1输入 git config --g global user.email "yabosun@163.com" 这里user.email为你GitHub账户绑定的邮箱 检查是否有.ssh文件1输入 cd ~/.ssh 生成密钥1输入 ssh-keygen -t rsa -C "yabosun@163.com" 连续回车 添加密钥到ssh-agent1输入 eval "$(ssh-agent -s)" 添加生成的SSH key到ssh-agent1输入 ssh-add ~/.ssh/id_rsa 登陆Github，点击头像下的settings，添加ssh新建一个ssh将C:\Users\yabosun\ssh路径下（这里要对应自己电脑的路径）的 id_rsa.pub文件中的内容复制到key 1输入ssh -T git@github.com 注意这里不用改任何名称。 配置Deploy 在你的博客所在文件夹根目录，例如我的是在F:\BlogWorkspace找到_config.yml文件，点击编辑，我是用的SublimeText3打开的，在文件末尾输入： 这里需要注意的是格式一定是：后跟一个空格，是它固定的格式，我一开始就在这里掉了坑，名称对应自己的GitHub项目名称，登陆你的GitHub账户，进入之前创建的Repository，点击Clone or download，选择Clone with SSH并复制就是你的repository 到这里基本上博客已经搭建成功，接下来安装扩展 1输入 npm install hexo-deployer-git --save 使用MarkDown编辑器编写好文章，编辑器最开始可以使用CSDN或者简书等博客内置的编辑器，Windows上推荐使用MarkDownPad2编辑器，不过我用了一下，别的功能还好，如果是要插入图片或者一些高级功能需要升级（付费），所以我现在基本就是在csdn编辑，然后导出MD文件，并上传到Github。另外你也可以直接使用命令生成MD文档： 1输入 hexo n "title" 这里的title是你文章的标题，这个时候你可以看到在F:\BlogWorkspace\source\_posts这个文件夹下会生成你命名的MD文章，打开可以直接编辑，具体的MarkDown语法可以参考这篇文章http://franky47.cn/2018/01/20/How%20to%20use%20MarkdownEditer/#more 生成并部署你的文章到GitHub服务器上1输入 hexo g -d 部署成功后访问你的地址：http://用户名.github.io，即可看到你文章的界面。到这里，基本的Hexo网站已经搭建完成。 参考使用Hexo+Github一步步搭建自己的博客Node.js安装配置]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GithubPages</tag>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2018%2F01%2F27%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[今天是2018年1月27日，武汉迎来了一场久违的大雪，好久之前就想着搭建博客，写写自己平时的一些心得体会。但是奈何一直沉（mang）迷（yu）学（suo）习（shi），直到上周才断断续续的搭建起最初的版本欢迎访问，后续再慢慢的更新优化。今天也算是博客网站初次搭建好第一次开始写自己的博客，所以还是蛮有纪念意义的。趁着今天这个日子，写一下自己的一些感想，包括对过去半年的总结，以及对2018年的憧憬。 总结过去 认知 日子真的是过的蛮快，经常就是一看日期，卧槽，又周日了？！细细回想，这半年来还是经历了很多。最初读研的想法就是觉得自己在大学阶段实在是没有学到什么，不知道自己怎么去找到一份满意的工作，所以读研的最开始还是怀着一颗努力学习的心的，看各种教学视频，看牛人的博客，制定自己的学习目标，摸索编译器的使用，看别人的学习经验，也是在这个阶段打定主意以后更多的从事跟Java有关的工作，可能也没什么原因，就是简单的觉得看着舒服。 懵逼 跟导师说明自己的想法后，很快给了我一个锻炼的机会，用Java实现一个算法，当时满怀欣喜，但是等到真正下手的时候却不知道该怎么做，所以那段时间也是一直都没啥进展，只是知道算法的流程，真的写代码时候一脸懵逼，写代码我觉得最初还是要有看的见的东西，才能提起兴趣，就这样很快半个多月就过去了，在这里要特别的感谢自己研究生的导师，并不是像别人说的研究生导师与学生是老板与员工的关系，老师真的很认真的给我讲解，甚至亲手教我一行一行的怎么实现一个简单的算法，蓝而，我最后还是没能把那个算法写出来。 迷茫 就这样到了正式开学，我还是脑子一片迷茫，进入实验室项目组，看了一段时间项目的代码，等到写月底总结的时候，突然发现，自己啥新的功能也没有实现，交代的任务也是做的一塌糊涂，真的毫无成就感，很多时候甚至怀疑自己是不是不适合敲代码，不懂该怎么下手，感觉东西学了很快就忘。还有就是本身对MFC实在提不起兴趣。 新奇 再到后来就没有做公司的项目，跑去跟导师做事情，这个过程也是收获蛮多的，学会了使用Github？SVN？好吧，你会说这些不算，老师让我去学了一下一款轻量级数据库SQlite，学了一些语法，然后就开始着手将已有的地质数据导入到这个数据库，当然这个时候实现都是用的C++，简单说，就是模仿老师写的代码，实现基本相似的功能，好，终于有了一些进展，看到自己成功把数据一行一行用代码导入数据库心里还是蛮开心的，但是，这个乱码是什么鬼！就不能给我一个完美的机会？当然在老师的帮助下修改了，后面就做了一段时间的小蜜蜂，哦不，砖瓦工更合适些。一天老师把我叫去，说这段时间你也模仿实现了一些，接下来就自己写，你实现一下这个功能，生成一个断层面，what？不懂。虽然嘴上嗯，心里还是没太搞明白。 磨练 差不多就到了快10月，后面就是自己的兼职实习阶段，感谢威总带我，走上了Android开发之路，去公司还是跟实验室不一样的，公司催的很紧，你必须得出东西，所以压力还是有点的，仗着脸皮厚，有时候没写出来还是拖了些天才提交，代码质量自然不用多说，现在回头看看之前写的，有点想打死自己，虽然被疯狂怼还是努力的做，也感觉自己收获很大，至少能看别人的代码，自己照着实现，然后能调通这个功能了，虽然经常因为命名混乱，考虑不周被怼，但是还是有些成就感，学到了很多Android基础的编程，这部分会在后面的博客中详细记录。 致谢 首先要感谢我家小七，今天也是相恋537天，感谢一路的陪伴，感谢对我的照顾。再次就是感谢遇到自己现在的导师，感谢对我的包容，对我的细心指导。最想感谢的还有就是威总，在我编程学习阶段给我很多的帮助，帮我调bug，虽然每次一脸嫌弃哈哈。还有就是感谢公司，感谢老王，让我看到自己身上最大的不足，就是学一个东西，没有认真的弄明白，只是简单的去模仿，没有真正的搞懂。也感谢遇到133的一群机电大佬（不是基佬），一起开黑，一起上分。OK，矫情的话就说到这。 展望未来2018简单计划： 旅游 争取抽时间出去旅游2次，目前考虑的城市有西安、成都、杭州、上海，具体待定，我带上钱，你带上我@王七宝 学习 深入学习Android，包括安卓的一些优化学习Java，多线程编程、网络编程学习web开发相关，包括JS、HTML等学习python，具体还没有了解，涉及到深度学习，人工智能学习在Linux系统编程开发扎实计算机基础，抽时间把计算机网络、计算机操作系统、数据结构等计算机基础课程学习一下，通过牛客网编程至少通过100 当然最大需要改变的就是以后学习东西要努力去深入了解，不要还是走马观花。想法总是美好的，现实可能很残酷，希望等到2019年看这篇博客时能没那么多后悔，而更多的是收获满满。加油！]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>日常随笔</tag>
      </tags>
  </entry>
</search>
